"""
电磁信号去噪主程序
修复内容：维度错误、变量命名、模型加载、可视化流程
"""

import argparse
import numpy as np
import torch
import matplotlib

matplotlib.use('Agg')  # 无GUI模式
from pathlib import Path
from sklearn.preprocessing import RobustScaler
from models import EnhancedDAE
from utils import visualize_denoising  # 使用更新后的可视化函数


def load_model(model_path, input_size):
    """加载预训练模型"""
    model = EnhancedDAE(input_size=input_size)
    try:
        model.load_state_dict(torch.load(model_path))
    except RuntimeError as e:
        raise ValueError(f"模型加载失败，请检查input_size参数: {e}")
    model.eval()
    return model


def process_channel(ch_idx, model, scaler, raw_signal, window_size=128):
    """处理单个通道的完整流程"""
    # 数据标准化
    scaled_signal = scaler.fit_transform(raw_signal.reshape(-1, 1)).flatten()

    denoised = np.zeros_like(scaled_signal)
    counts = np.zeros_like(scaled_signal)
    chunk_size = 10000  # 分块处理防止内存溢出

    with torch.no_grad():
        # 分块处理大文件
        for start in range(0, len(scaled_signal), chunk_size):
            end = min(start + chunk_size + window_size, len(scaled_signal))
            chunk = scaled_signal[start:end]

            # 滑动窗口处理
            for i in range(0, len(chunk) - window_size + 1):
                window = chunk[i:i + window_size]
                window_tensor = torch.FloatTensor(window).unsqueeze(0)  # [1, window_size]

                # 模型推理
                reconstructed = model(window_tensor).squeeze(0).numpy()

                # 重叠区域累加
                denoised[start + i:start + i + window_size] += reconstructed
                counts[start + i:start + i + window_size] += 1

    # 归一化并逆标准化
    denoised = denoised / (counts + 1e-8)
    return scaler.inverse_transform(denoised.reshape(-1, 1)).flatten()


def main():
    # 参数解析
    parser = argparse.ArgumentParser(description='电磁信号去噪')
    parser.add_argument('--data_path', type=str, required=True, help='输入数据文件路径')
    parser.add_argument('--output_path', type=str, default='./outputs/x100/自编码model4/denoised.txt',
                        help='去噪结果保存路径')
    parser.add_argument('--model_dir', type=str, default='./models/with_noise_model4',
                        help='模型文件目录')
    parser.add_argument('--window', type=int, default=1024,
                        help='必须与训练时使用的窗口大小一致')
    args = parser.parse_args()

    # 创建输出目录
    Path(args.output_path).parent.mkdir(parents=True, exist_ok=True)

    # 加载原始数据（假设数据有至少9列）
    raw_data = np.loadtxt(args.data_path)
    assert raw_data.shape[1] >= 9, "输入数据需要至少9列"

    # 通道配置
    CHANNEL_NAMES = ['HX (水平X)', 'HY (水平Y)', 'HZ (垂直)']
    processed = raw_data.copy()

    # 逐通道处理
    for ch in range(3):
        print(f"处理通道 {ch}...")
        try:
            # 加载对应通道模型
            model_path = Path(args.model_dir) / f"noisy_ch{ch}_best.pth"
            model = load_model(model_path, args.window)

            # 处理数据
            processed[:, 6 + ch] = process_channel(
                ch, model,
                RobustScaler(),
                raw_data[:, 6 + ch],
                window_size=args.window
            )

            # 生成可视化结果（显示前1000个样本）
            show_points = min(100000, len(raw_data))  # 确保不超过数据长度
            visualize_denoising(
                original=raw_data[:show_points, 6 + ch],
                denoised=processed[:show_points, 6 + ch],
                channel_name=CHANNEL_NAMES[ch],
                save_path=f"{Path(args.output_path).parent}/channel_{ch}_compare.png"
            )
        except Exception as e:
            print(f"通道 {ch} 处理失败: {str(e)}")
            continue

    # 保存结果
    np.savetxt(args.output_path, processed, fmt='%.6f')
    print(f"去噪结果已保存至 {args.output_path}")


if __name__ == "__main__":
    main()
