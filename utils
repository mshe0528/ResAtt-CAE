# # import numpy as np
# # import matplotlib.pyplot as plt
# # from sklearn.preprocessing import RobustScaler
# # from torch.utils.data import Dataset, DataLoader
# # import torch
# # from torch.utils.data import Dataset, DataLoader
# # class LTMDataset(Dataset):
# #     """大地电磁数据集"""
# #
# #     def __init__(self, data_path, target_channels, window_size=64,
# #                  stride=32, mode='train'):
# #         raw_data = np.loadtxt(data_path)
# #         self.channels = raw_data[:, [6, 7, 8]]  # 7-9列
# #         self.scalers = [RobustScaler() for _ in range(3)]
# #
# #         # 分通道标准化
# #         for i in range(3):
# #             self.channels[:, i] = self.scalers[i].fit_transform(
# #                 self.channels[:, i].reshape(-1, 1)).flatten()
# #
# #         # 创建滑动窗口
# #         self.windows = []
# #         for ch in target_channels:
# #             channel_data = self.channels[:, ch]
# #             for i in range(0, len(channel_data) - window_size, stride):
# #                 window = channel_data[i:i + window_size]
# #                 self.windows.append((window, window))  # 自编码器输入输出相同
# #
# #     def __len__(self):
# #         return len(self.windows)
# #
# #     def __getitem__(self, idx):
# #         inputs, targets = self.windows[idx]
# #         return (torch.FloatTensor(inputs),
# #                 torch.FloatTensor(targets))
# #
# #
# # def plot_comparison(original, denoised, channel, save_path):
# #     """绘制去噪对比图"""
# #     plt.figure(figsize=(12, 6))
# #     plt.plot(original, alpha=0.6, label='Original', linewidth=1)
# #     plt.plot(denoised, alpha=0.8, label='Denoised', linewidth=1.2)
# #     plt.title(f'Channel {channel} Denoising Result')
# #     plt.xlabel('Samples')
# #     plt.ylabel('Amplitude')
# #     plt.legend()
# #     plt.grid(True, alpha=0.3)
# #     plt.tight_layout()
# #     plt.savefig(save_path, dpi=300)
# #     plt.close()
#
# import numpy as np
# import os
# from sklearn.preprocessing import RobustScaler
# from torch.utils.data import Dataset
# import torch
# import matplotlib
# matplotlib.use('Agg')  # 非交互式后端，避免GUI依赖
# import matplotlib.pyplot as plt
# plt.rcParams['font.sans-serif']=['SimHei']
# plt.rcParams['axes.unicode_minus']=False
# from sklearn.preprocessing import RobustScaler
# import numpy as np
# from torch.utils.data import Dataset
# import random
#
# def plot_comparison(original, denoised, channel_name, save_path):
#     """绘制去噪前后对比图"""
#     plt.figure(figsize=(15, 8))
#
#     # 时域对比
#     plt.subplot(2, 2, 1)
#     plt.plot(original, alpha=0.6, label='原始信号', linewidth=1)
#     plt.plot(denoised, alpha=0.8, label='去噪结果', linewidth=1.2)
#     plt.title(f'{channel_name} 通道时域对比')
#     plt.xlabel('样本点')
#     plt.ylabel('幅值')
#     plt.legend()
#     plt.grid(True, alpha=0.3)
#
#     # 残差分布
#     plt.subplot(2, 2, 2)
#     residual = original - denoised
#     plt.hist(residual, bins=50, alpha=0.7, color='purple')
#     plt.title('残差分布直方图')
#     plt.xlabel('残差值')
#     plt.ylabel('频数')
#
#     # 频域对比
#     plt.subplot(2, 2, 3)
#     f_orig = np.abs(np.fft.rfft(original))
#     f_denoised = np.abs(np.fft.rfft(denoised))
#     freq = np.fft.rfftfreq(len(original))
#     plt.semilogy(freq, f_orig, alpha=0.6, label='原始')
#     plt.semilogy(freq, f_denoised, alpha=0.8, label='去噪')
#     plt.title('频域能量对比')
#     plt.xlabel('频率 (Hz)')
#     plt.ylabel('幅值')
#     plt.legend()
#
#     # 时频分析
#     plt.subplot(2, 2, 4)
#     _, _, _, c = plt.specgram(denoised, Fs=1, NFFT=64, noverlap=32,
#                               cmap='viridis', vmin=-50, vmax=50)
#     plt.colorbar(c).set_label('能量 (dB)')
#     plt.title('去噪信号时频谱')
#
#     plt.tight_layout()
#     plt.savefig(save_path, dpi=150, bbox_inches='tight')
#     plt.close()
#
#
# class LTMDataset(Dataset):
#     def __init__(self, data_files, target_channels, window_size=64, stride=32):
#         self.window_size = window_size
#         self.stride = stride
#         self.target_channels = target_channels
#
#         # 初始化scaler
#         self.scalers = [RobustScaler() for _ in range(3)]
#         self._fit_scalers(data_files)  # 拟合scaler参数
#
#         # 处理每个文件生成窗口
#         self.windows = []
#         for file_path in data_files:
#             self._process_file(file_path)
#
#         print(f"总窗口数: {len(self.windows):,}")
#
#     def _fit_scalers(self, data_files):
#         """累积所有数据计算RobustScaler参数"""
#         all_data = []
#
#         # 第一步：收集所有数据
#         for file_path in data_files:
#             with open(file_path, 'r') as f:
#                 file_data = []
#                 for line in f:
#                     items = line.strip().split()
#                     if len(items) < 9: continue
#                     # 提取第7、8、9列（索引6,7,8）
#                     file_data.append([float(items[6]), float(items[7]), float(items[8])])
#                 if file_data:
#                     all_data.extend(file_data)
#
#         # 转换为NumPy数组
#         all_data = np.array(all_data)
#
#         # 拟合每个通道的scaler
#         for i in range(3):
#             self.scalers[i].fit(all_data[:, i].reshape(-1, 1))
#
#     def _process_file(self, file_path):
#         """处理单个文件生成窗口"""
#         # 加载文件数据
#         data = []
#         with open(file_path, 'r') as f:
#             for line in f:
#                 items = line.strip().split()
#                 if len(items) < 9: continue
#                 data.append([float(items[6]), float(items[7]), float(items[8])])
#         data = np.array(data)
#
#         # 应用标准化
#         scaled = np.zeros_like(data)
#         for i in range(3):
#             scaled[:, i] = self.scalers[i].transform(data[:, i].reshape(-1, 1)).flatten()
#
#         # 生成滑动窗口
#         for ch in self.target_channels:
#             ch_data = scaled[:, ch]
#             for i in range(0, len(ch_data) - self.window_size + 1, self.stride):
#                 window = ch_data[i:i + self.window_size]
#                 self.windows.append((window, window))  # 自编码器输入=输出
#
#     def __len__(self):
#         return len(self.windows)
#
#     def __getitem__(self, idx):
#         inputs, targets = self.windows[idx]
#         return (
#             torch.FloatTensor(inputs),
#             torch.FloatTensor(targets)
#         )
import torch
import matplotlib
matplotlib.use('Agg')  # 非交互式后端，避免GUI依赖
import matplotlib.pyplot as plt
plt.rcParams['font.sans-serif']=['SimHei']
plt.rcParams['axes.unicode_minus']=False
from sklearn.preprocessing import RobustScaler
import numpy as np
from torch.utils.data import Dataset
import random
import numpy as np
import matplotlib

matplotlib.use('Agg')
import matplotlib.pyplot as plt
from sklearn.preprocessing import RobustScaler
from torch.utils.data import Dataset
import random
# utils.py 新增以下代码
import matplotlib.pyplot as plt
import numpy as np


def visualize_denoising(original, denoised, channel_name, save_path):
    """去噪效果对比可视化（更新后的函数名）"""
    plt.figure(figsize=(16, 9))

    # 时域对比
    # plt.subplot(1, 2, 1)
    plt.plot(original, alpha=0.6, label='原始信号')
    plt.plot(denoised, alpha=0.8, label='去噪结果')
    plt.title(f"{channel_name} 通道时域对比")
    plt.xlabel("样本点")
    plt.ylabel("幅值")
    plt.legend()

    # # 残差分析
    # plt.subplot(1, 2, 2)
    # residual = original - denoised
    # plt.hist(residual, bins=50, color='purple', alpha=0.7)
    # plt.title("残差分布直方图")
    # plt.xlabel("残差值")
    # plt.ylabel("频数")

    plt.tight_layout()
    plt.savefig(save_path, dpi=300)
    plt.close()

def plot_comparison(original, denoised, channel_name, save_path):
    """绘制去噪前后对比图"""
    plt.figure(figsize=(12, 6))

    # 时域对比
    plt.subplot(1, 2, 1)
    plt.plot(original, alpha=0.6, label='原始信号', linewidth=1)
    plt.plot(denoised, alpha=0.8, label='去噪结果', linewidth=1.2)
    plt.title(f'{channel_name} 通道时域对比')
    plt.xlabel('样本点')
    plt.ylabel('幅值')
    plt.legend()
    plt.grid(True, alpha=0.3)

    # 残差分布
    plt.subplot(1, 2, 2)
    residual = original - denoised
    plt.hist(residual, bins=50, alpha=0.7, color='purple')
    plt.title('残差分布直方图')
    plt.xlabel('残差值')
    plt.ylabel('频数')

    plt.tight_layout()
    plt.savefig(save_path, dpi=120, bbox_inches='tight')
    plt.close()

class LTMDataset(Dataset):
    """支持动态噪声增强的电磁数据集"""

    def __init__(self, data_files, target_channels, window_size=64, stride=32, mode='train'):
        self.window_size = window_size
        self.stride = stride
        self.target_channels = target_channels
        self.mode = mode

        # 初始化标准化器
        self.scalers = [RobustScaler() for _ in range(3)]
        self._fit_scalers(data_files)

        # 构建数据集
        self.windows = []
        for file_path in data_files:
            self._process_file(file_path)

        print(f"总样本数: {len(self.windows)} | 模式: {mode}")

    def _fit_scalers(self, data_files):
        """全局标准化参数计算"""
        all_data = []
        for file_path in data_files:
            data = np.loadtxt(file_path, usecols=(6, 7, 8))
            all_data.append(data)
        merged = np.vstack(all_data)
        for i in range(3):
            self.scalers[i].fit(merged[:, i].reshape(-1, 1))

    def _process_file(self, file_path):
        """处理单个文件生成窗口"""
        data = np.loadtxt(file_path, usecols=(6, 7, 8))
        scaled = np.zeros_like(data)
        for i in range(3):
            scaled[:, i] = self.scalers[i].transform(data[:, i].reshape(-1, 1)).flatten()

        # 生成滑动窗口
        for ch in self.target_channels:
            ch_data = scaled[:, ch]
            for i in range(0, len(ch_data) - self.window_size + 1, self.stride):
                window = ch_data[i:i + self.window_size]
                self.windows.append(window)

    # def _add_dynamic_noise(self, clean_window):
    #     """动态噪声注入（核心增强方法）"""
    #     noisy = clean_window.copy()
    #
    #     # 噪声类型配置
    #     noise_config = [
    #         {'type': 'gaussian', 'prob': 0.7, 'scale': 0.1},  # 高斯噪声
    #         {'type': 'impulse', 'prob': 0.3, 'rate': 0.005},  # 脉冲噪声
    #         {'type': 'periodic', 'prob': 0.4, 'freq': 0.5},  # 工频干扰
    #         {'type': 'baseline', 'prob': 0.2, 'strength': 0.2},  # 基线漂移
    #     ]
    #
    #     # 随机应用两种噪声
    #     selected = random.sample(noise_config, k=2)
    #
    #     for cfg in selected:
    #         if random.random() > cfg['prob']:
    #             continue
    #
    #         if cfg['type'] == 'gaussian':
    #             noise = np.random.normal(0, cfg['scale'], self.window_size)
    #             noisy += noise
    #
    #         elif cfg['type'] == 'impulse':
    #             mask = np.random.rand(self.window_size) < cfg['rate']
    #             impulse = np.random.choice([-1, 1], mask.sum()) * 0.5
    #             noisy[mask] += impulse
    #
    #         elif cfg['type'] == 'periodic':
    #             t = np.linspace(0, 1, self.window_size)
    #             noise = 0.3 * np.sin(2 * np.pi * cfg['freq'] * t)
    #             noisy += noise
    #
    #         elif cfg['type'] == 'baseline':
    #             drift = np.linspace(0, cfg['strength'], self.window_size)
    #             drift *= np.random.choice([-1, 1])
    #             noisy += drift
    #     return noisy
    def _add_dynamic_noise(self, clean_window):
        """低频大地电磁噪声综合模拟(修复版)"""
        noisy = clean_window.copy()
        fs = 1.0  # 采样频率1Hz
        t = np.arange(len(clean_window)) / fs

        # 新增参数安全校验函数
        def safe_range_params(value):
            """确保range参数有效性(关键修复点)"""
            return max(1, int(value))  # 强制最小值1[1,3](@ref)

        # 噪声配置字典
        noise_config = {
            # 磁暴干扰（超低频非线性漂移）
            'geomagnetic_storm': {
                'prob': 0.7,
                'strength': 0.4,
                'duration_ratio': 0.3
            },
            # 地磁脉动干扰（Pc型规则/ Pi型随机）
            'pulsation': {
                'pc_prob': 0.6,
                'freq_range': (0.01, 0.1),
                'pi_std': 0.15
            },
            # 工业游散电流（方波+三角波耦合）
            'industrial_current': {
                'prob': 0.5,
                'pulse_ratio': 0.001,
                'triangle_phase': 0.3,
                'min_duration': 0.2  # 新增最小持续时间约束[3](@ref)
            },
            # 电力系统瞬态（基线漂移+脉冲）
            'power_system': {
                'baseline_slope': 0.02,
                'spike_ratio': 0.0005
            },
            # 仪器噪声（高斯白噪声+共模偏移）
            'instrument_noise': {
                'white_noise': 0.05,
                'common_mode': 0.1
            }
        }

        # === 磁暴干扰模拟 ===#
        if random.random() < noise_config['geomagnetic_storm']['prob']:
            duration = safe_range_params(len(clean_window) * noise_config['geomagnetic_storm']['duration_ratio'])
            storm_base = np.linspace(0, 1, duration)
            storm_wave = np.interp(t, storm_base,
                                   noise_config['geomagnetic_storm']['strength'] * np.random.randn(duration))
            noisy += storm_wave

        # === 地磁脉动干扰 ===#
        if random.random() < noise_config['pulsation']['pc_prob']:
            freq = np.random.uniform(*noise_config['pulsation']['freq_range'])
            pc_wave = 0.2 * np.sin(2 * np.pi * freq * t + np.random.rand() * 2 * np.pi)
            noisy += pc_wave
        else:
            pi_wave = np.cumsum(np.random.normal(0, noise_config['pulsation']['pi_std'], len(t)))
            noisy += pi_wave - np.mean(pi_wave)

        # === 工业游散电流干扰 ===#
        if random.random() < noise_config['industrial_current']['prob']:
            # 修复1：安全参数计算
            square_duration = safe_range_params(fs * np.random.uniform(
                noise_config['industrial_current']['min_duration'], 2))

            # 修复2：动态调整脉冲区间
            valid_intervals = np.where(np.random.rand(len(t)) < noise_config['industrial_current']['pulse_ratio'])[0]
            square_mask = np.zeros_like(t)

            # 修复3：安全区间设置
            for idx in valid_intervals:
                start = idx
                end = min(idx + square_duration, len(t))
                if end > start:  # 确保有效区间
                    square_mask[start:end] = 1

            square_wave = 0.5 * (square_mask - 0.5)

            # 修复4：三角波相位校验
            triangle_phase = safe_range_params(len(t) * noise_config['industrial_current']['triangle_phase'])
            triangle_wave = 0.3 * np.concatenate([
                np.linspace(-1, 1, triangle_phase),
                np.linspace(1, -1, safe_range_params(len(t) - triangle_phase))  # 保证非负长度
            ])
            noisy += square_wave + triangle_wave[::np.random.choice([-1, 1])]

        # === 电力系统瞬态干扰 ===#
        # 修复5：基线漂移参数限制
        baseline_slope = np.clip(noise_config['power_system']['baseline_slope'], -0.1, 0.1)
        baseline_drift = np.linspace(0, baseline_slope * np.random.randn(), len(t))
        noisy += baseline_drift

        # 修复6：尖峰位置校验
        spike_positions = np.where(np.random.rand(len(t)) < noise_config['power_system']['spike_ratio'])[0]
        if len(spike_positions) > 0:
            noisy[spike_positions] += 3 * np.random.randn(len(spike_positions))

        # === 仪器噪声 ===#
        noisy += np.random.normal(0, noise_config['instrument_noise']['white_noise'], len(t))
        noisy += noise_config['instrument_noise']['common_mode'] * np.random.choice([-1, 1])

        # === 频段增强（死频段现象）===#
        fft_noise = np.fft.rfft(noisy - clean_window)
        freq = np.fft.rfftfreq(len(noisy), d=1 / fs)
        mask = (freq >= 0.1) & (freq <= 1)
        fft_noise[mask] *= 1.5
        noisy = clean_window + np.fft.irfft(fft_noise, n=len(noisy)).real

        return np.clip(noisy, -1, 1)

    def __len__(self):
        return len(self.windows)

    def __getitem__(self, idx):
        clean = self.windows[idx]

        if self.mode == 'train':
            # 训练模式添加动态噪声
            noisy = self._add_dynamic_noise(clean)
            return torch.FloatTensor(noisy), torch.FloatTensor(clean)
        else:
            # 验证/测试模式保持干净
            return torch.FloatTensor(clean), torch.FloatTensor(clean)


def plot_noise_comparison(clean, noisy, save_path):
    """噪声增强可视化"""
    plt.figure(figsize=(15, 6))

    plt.subplot(2, 1, 1)
    plt.plot(clean, label='Clean', alpha=0.8)
    plt.plot(noisy, label='Noisy', alpha=0.6)
    plt.title('Time Domain Comparison')
    plt.legend()

    plt.subplot(2, 1, 2)
    plt.magnitude_spectrum(clean, Fs=1, label='Clean', alpha=0.8)
    plt.magnitude_spectrum(noisy, Fs=1, label='Noisy', alpha=0.6)
    plt.title('Frequency Domain')
    plt.legend()

    plt.tight_layout()
    plt.savefig(save_path, dpi=120)
    plt.close()
